---
title: "Understanding the problem"
slug: "understanding-the-problem"
description: "Some early thoughts about the situation and exploring options available - it's been a few years since I've been active with the project and a lot has changed around the GitHub API landscape."
weight: 1
---

A project that I've had my eye on for a while is [`octokit/routes`](https://github.com/octokit/routes),
which maintains an OpenAPI spec for the GitHub v3 API, along with supported
versions of GitHub Enterprise. To you this might seem unimportant given there's
a bunch of existing client libraries for the GitHub API, but I can think of
several ways that it's valuable to Octokit.net:

 - If there's an up-to-date specification, can I validate the client does what
   it's supposed to do?
 - When GitHub adds new APIs or makes changes existing ones, can we use the
   schema to identify gaps in our client that need to be addressed?
 - What if we generated the client code using the specification, so we're
   always up to date?

That last question has been bugging me ever since I started thinking about it,
and I knew I had to write some code to see what a solution might look like.

## The Goal

**Can we generate C# code for a subset of the GitHub API that can slot nicely
into Octokit.net?**

My theory was that I could do this in a number of steps:

 1. Parse the routes information from `octokit/routes` OpenAPI specification
    and grab the relevant subset of information
 2. Convert that into a representation that makes sense for Octokit.net
 3. Generate and splat the C# files onto disk inside the Octokit.net project
   using Roslyn
 4. See if the project would compile and pass the test suite

Some obvious questions you might have:

> If you have an OpenAPI spec, why not just use an existing library and generate
the client code using that, rather than rolling your own?

I want this new code to adhere to the decisions and conventions we've used
throughout the Octokit.net codebase for a few reasons:

 - I feel that the code generated by these tools will be very different, and the
   work required to massage the output through extensibility options (if they
   even provide them) will offset any gains provided by using the tool
 - I don't want existing users of the library to have to rewrite their working
   code to suit a different API, and by controlling the output we can keep
   breaking changes to a minimum
 - By keeping the codegen tool alongside the client code in the same repository
   we can evolve them in step and keep them in sync

I think this exercise will help me codify the conventions we have built up, and
provide an opportunity to clarify whether they are still working for us.

> Roslyn seems excessive for the job - why not just build up some strings
instead or use a templating engine like Mustache?

This would be ideal for a quick demo, but I had a suspicion that others have
already used Roslyn for these sorts of capabilities so I chose to
add that into the mix and learn from what others have done with Roslyn.

I was also nervous that this wouldn't scale for the more complex parts of
Octokit.net, and so leaning on something Roslyn-based could help catch mistakes
earlier in the process if we decide to leverage it.

> How correct can your generated code be? And how much do you trust it?

I'm not concerned about the distinction between generated code and manual code,
because they can both rely on the plumbing we've built up over the years to
ensure callers behave consistently.

And because of our convention tests, we can automatically verify that new
contributions align with the existing codebase, or we can add more tests if we
uncover differences we should handle to ensure we don't regress.
